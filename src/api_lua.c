#include "smgf.h"
#include "api_lua.h"

// searches for a module name in a search path (usually package.path):
// tries to open files and return the filename of the first file that could be
// opened + pushes it onto the Lua stack.
const char* searchpath(
    lua_State* L, const char* name, const char* path, const char* sep,
    const char* dirsep) {
  // we replace Lua's "." directory separator with a slash (for physfs),
  // and create a new path variable with "?" characters replaced by module name
  const char* name_withdirsep = luaL_gsub(L, name, ".", dirsep);
  const char* path_withmodname =
      luaL_gsub(L, path, LUA_PATH_MARK, name_withdirsep);

  // we iterate over all paths (which are separated by a ";")
  const char* const path_start = path_withmodname;
  const char* const path_end = path_withmodname + strlen(path_withmodname);
  const char* path_curpos = path_start;

  while (path_curpos < path_end) {
    const char* separator_pos = strchr(path_curpos, *sep);

    // if there's no more separator in string, we set the separator to end
    // of string
    if (separator_pos == NULL) {
      separator_pos = path_end;
    }

    lua_pushlstring(L, path_curpos, separator_pos - path_curpos);
    const char* p = lua_tostring(L, -1);

    // note: physfs returns a PHYSFS_ERR_BAD_FILENAME error
    // if filename starts with "./", so we skip the "." with "+ 1":
    if (PHYSFS_exists(p + 1) != 0) {
      lua_remove(L, -2); // remove strings generated by gsub
      lua_remove(L, -3);
      return p + 1;
    }

    lua_pop(L, 1);
    path_curpos = separator_pos + 1;
  }

  lua_pop(L, 2); // remove strings generated by gsub
  return NULL;
}

// custom smgf package.searcher that tries to load modules through physfs
int l_smgf_searcher(lua_State* L) {
  // smgf* const c = get_smgf(L);
  const char* mod_name = luaL_checkstring(L, 1);

  lua_getglobal(L, "package");
  lua_getfield(L, -1, "path");
  const char* packagepath = luaL_checkstring(L, -1);

  // finding a file matching the module name
  const char* file_name =
      searchpath(L, mod_name, packagepath, LUA_PATH_SEP, "/");

  if (file_name == NULL) {
    return luaL_error(
        L, "module '%s' not found in smgf game folders.", mod_name);
  }

  // loading file
  PHYSFS_file* file = PHYSFS_openRead(file_name);

  if (file == NULL) {
    int error_code = PHYSFS_getLastErrorCode();
    return luaL_error(
        L, "error opening file '%s': %s (%d)", file_name,
        PHYSFS_getErrorByCode(error_code), error_code);
  }

  int file_len = PHYSFS_fileLength(file);

  char* file_contents = calloc(file_len, sizeof(char));
  if (PHYSFS_readBytes(file, file_contents, file_len) != file_len) {
    int error_code = PHYSFS_getLastErrorCode();
    return luaL_error(
        L, "error reading file '%s': %s (%d)", file_name,
        PHYSFS_getErrorByCode(error_code), error_code);
  }

  // loading Lua string
  luaL_loadbuffer(L, file_contents, file_len, mod_name);
  lua_pushstring(L, mod_name);

  free(file_contents);
  PHYSFS_close(file);

  return 2;
}

// initialises a Lua state for smgf use
void lua_api_init(smgf* const c) {
  // store a pointer to smgf struct in Lua registry
  lua_pushstring(c->L, SMGF_PTRNAME);
  lua_pushlightuserdata(c->L, (void*) c);
  lua_settable(c->L, LUA_REGISTRYINDEX);

  // open standard libs
  luaL_openlibs(c->L);

  // remove almost entire io module, except: io.flush, io.write, io.stderr,
  // io.stdout
  lua_getglobal(c->L, "io");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "close");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "input");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "lines");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "open");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "output");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "popen");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "read");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "stdin");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "tmpfile");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "type");
  lua_pop(c->L, 1);

  // remove some functions from os module
  lua_getglobal(c->L, "os");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "execute");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "exit");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "getenv");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "remove");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "rename");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "setlocale");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "tmpname");
  lua_pop(c->L, 1);

  // remove dofile & loadfile
  lua_pushnil(c->L);
  lua_setglobal(c->L, "dofile");
  lua_pushnil(c->L);
  lua_setglobal(c->L, "loadfile");

  // set package.path + cpath
  lua_getglobal(c->L, "package");
  lua_pushstring(c->L, "./?.lua;./?/init.lua");
  lua_setfield(c->L, -2, "path");
  lua_pushstring(c->L, "");
  lua_setfield(c->L, -2, "cpath");
  lua_pop(c->L, 1);

  // we have to setup a custom package loader into package.searchers
  // so that modules are loaded through physfs
  // We overwrite package.searcher nÂ°2 (the one using package.path). See:
  // https://www.lua.org/manual/5.4/manual.html#pdf-package.searchers
  lua_getglobal(c->L, "package");
  lua_getfield(c->L, -1, "searchers");
  lua_pushcfunction(c->L, l_smgf_searcher);
  lua_rawseti(c->L, -2, 2);
  // removing 3st & 4th package searchers that allow module loading
  // from C libraries:
  lua_pushnil(c->L);
  lua_rawseti(c->L, -2, 3);
  lua_pushnil(c->L);
  lua_rawseti(c->L, -2, 4);
  lua_pop(c->L, 1);
  // removing package.searchpath & package.loadlib
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "searchpath");
  lua_pushnil(c->L);
  lua_setfield(c->L, -2, "loadlib");
  lua_pop(c->L, 1);

  // add smgf table
  lua_newtable(c->L); // create smgf table

  // add modules to smgf table
  init_audio(c->L);
  init_graphics(c->L);
  init_input(c->L);
  init_io(c->L);
  init_system(c->L);

  // set smgf table global
  lua_setglobal(c->L, "smgf");
}
